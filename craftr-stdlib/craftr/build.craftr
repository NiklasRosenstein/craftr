# This file is loaded by the craftr.main.Context where the `context`
# variable is available.

project "craftr" v1.0.0
eval:>>

__all__ = __builtins__ = ['BUILD', 'OS', 'path', 'error', 'fmt', 'glob']

from nr import fs as path
from nr.types import Named
from nr.stream import stream

import collections
import os
import platform
import sys
import types

import {BuildBackend} from '@craftr/craftr-build/build'
import {TargetHandler} from '@craftr/craftr-build/core'
import {ExplicitRunError} from '@craftr/craftr-build/dsl'
import {Bool, Integer, String, Path, List, Dict, StringList, PathList} from '@craftr/craftr-build/proplib'
import io from '@craftr/craftr-build/utils/io'
import sh from '@craftr/craftr-build/utils/sh'


def error(*message):
  """
  Raises an #ExplicitRunError with the specified message.
  """

  raise ExplicitRunError(' '.join(map(str, message)))


error.Type = ExplicitRunError


def fmt(s, frame=None):
  """
  Formats the string *s* with the variables from the parent frame or the
  specified frame-object *frame*.
  """

  import inspect
  import gc
  import types
  class Resolver:
    def __init__(self, frame):
      self.frame = frame
      self._func = NotImplemented
    @property
    def func(self):
      if self._func is NotImplemented:
        self._func = next(filter(lambda x: isinstance(x, types.FunctionType),
            gc.get_referrers(self.frame.f_code)), None)
      return self._func
    def __getitem__(self, key):
      # Try locals
      try: return self.frame.f_locals[key]
      except KeyError: pass
      # Try non-locals
      try:
        index = self.frame.f_code.co_freevars.index(key)
      except ValueError:
        pass
      else:
        if self.func:
          x = self.func.__closure__[index]
          return x
      # Try globals
      g = self.frame.f_globals
      g = g.get('__dict__', g)
      try: return g[key]
      except KeyError: pass
      raise KeyError(key)

  frame = frame or inspect.currentframe().f_back
  vars = Resolver(frame)
  return s.format_map(vars)


def glob(patterns, parent=None, excludes=None):
  if not parent:
    obj = context.current_target or context.current_module
    parent = obj.directory
  return path.glob(patterns, parent, excludes)


def load_target(name):
  module, target_name = name.partition('@')[::2]
  return context.load_module(module).targets[target_name]


def relocate_files(parent, files, outdir, suffix, replace_suffix=True):
  """
  Converts the list of filenames *files* so that they are placed under
  *outdir* instead of *parent* and have the specified *suffix*. If
  *replace_suffix* is #True (default), then the file's suffix will be
  replaced, otherwise appended.
  """

  outdir = path.canonical(outdir)
  parent = path.canonical(parent)

  result = []
  for filename in files:
    filename = path.join(outdir, path.rel(path.canonical(filename), parent))
    filename = path.addsuffix(filename, suffix, replace=replace_suffix)
    result.append(filename)

  return result


class OsInfo(Named):
  __annotations__ = [
    ('name', str),
    ('id', str),
    ('type', str),
    ('arch', str)
  ]

  @classmethod
  def new(cls):
    if sys.platform.startswith('win32'):
      return cls('windows', 'win32', os.name, 'x86_64' if os.environ.get('ProgramFiles(x86)') else 'x86')
    elif sys.platform.startswith('darwin'):
      return cls('macos', 'darwin', 'posix', 'x86_64' if sys.maxsize > 2**32 else 'x86')
    elif sys.platform.startswith('linux'):
      return cls('linux', 'linux', 'posix', 'x86_64' if sys.maxsize > 2**32 else 'x86')
    else:
      raise EnvironmentError('(yet) unsupported platform: {}'.format(sys.platform))


class BuildInfo(Named):
  __annotations__ = [
    ('variant', str)
  ]

  @property
  def debug(self):
    return self.variant == 'debug'

  @property
  def release(self):
    return self.variant == 'release'


OS = OsInfo.new()
BUILD = BuildInfo(context.build_variant)
