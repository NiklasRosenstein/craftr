project "backends/ninja" v1.0.0

options:
  # Force a local installation of Ninja -- automatically downloading an
  # appropriate version from the GitHub releases page. If Ninja is not
  # present on the current system or the version is not matching the Craftr
  # requirements, it will be downloaded anyway.
  bool local = False

eval:>>

import io
import os
import nodepy
import re
import requests
import shlex
import shutil
import subprocess
import sys
import zipfile

import {quote} from '@craftr/craftr-build/utils/sh'
import craftr from 'craftr'
import {ActionServer} from './actionserver'
import ninja_syntax from './ninja_syntax'
import {options} from './build.craftr'

NINJA_FILENAME = 'ninja' + ('.exe' if os.name == 'nt' else '')
NINJA_MIN_VERSION = '1.7.1'
if OS.id == 'win32':
  NINJA_PLATFORM = 'win'
elif OS.id == 'darwin':
  NINJA_PLATFORM = 'mac'
elif OS.id == 'linux':
  NINJA_PLATFORM = 'linux'
else:
  raise EnvironmentError('Ninja backend on {!r} currently not supported'
    .format(OS.id))
NINJA_URL = 'https://github.com/ninja-build/ninja/releases/download/v1.8.2/ninja-{}.zip'.format(NINJA_PLATFORM)


def check_ninja_version(build_directory, download=False):
  # If there's a local ninja version, use it.
  local_ninja = os.path.join(build_directory, NINJA_FILENAME)
  if os.path.isfile(local_ninja):
    ninja = local_ninja
  elif not options.local:
    # Otherwise, check if there's a ninja version installed.
    ninja = shutil.which('ninja')
  else:
    ninja = None

  # Check the minimum Ninja version.
  if ninja:
    ninja_version = subprocess.check_output([ninja, '--version']).decode().strip()
    if not ninja_version or ninja_version < NINJA_MIN_VERSION:
      print('note: need at least ninja {} (have {} at "{}")'.format(NINJA_MIN_VERSION, ninja_version, ninja))
      ninja = None
      ninja_version = None

  if not ninja and download:
    # Download a new Ninja version into the build directory.
    ninja = local_ninja
    print('note: downloading Ninja ({})'.format(NINJA_URL))
    with zipfile.ZipFile(io.BytesIO(requests.get(NINJA_URL).content)) as zfile:
      with zfile.open(NINJA_FILENAME) as src:
        with open(ninja, 'wb') as dst:
          shutil.copyfileobj(src, dst)
      os.chmod(ninja, int('766', 8))
    ninja_version = subprocess.check_output([ninja, '--version']).decode().strip()

  if not download and ninja_version:
    print('note: Ninja v{} ({})'.format(ninja_version, ninja))
  return ninja


class NinjaBackend(craftr.BuildBackend):

  def export(self):
    graph = self.context.graph
    build_directory = self.context.build_directory

    check_ninja_version(build_directory, download=True)

    build_file = os.path.join(build_directory, 'build.ninja')
    if os.path.exists(build_file) and os.path.getmtime(build_file) >= graph.mtime():
      return  # Does not need to be re-exported, as the build graph hasn't changed.

    print('note: writing "{}"'.format(build_file))
    with open(build_file, 'w') as fp:
      writer = ninja_syntax.Writer(fp, width=9000)
      writer.comment('This file was automatically generated by Craftr')
      writer.comment('It is not recommended to edit this file manually.')
      writer.newline()

      # writer.variable('msvc_deps_prefix')  # TODO
      writer.variable('builddir', build_directory)
      writer.variable('python', ' '.join(map(quote, nodepy.runtime.exec_args)))
      writer.newline()

      non_explicit = []
      for action in sorted(graph.actions(), key=lambda x: x.name):
        try:
          export_action(build_directory, writer, graph, action, non_explicit)
          writer.newline()
        except Exception as e:
          raise RuntimeError('error while exporting {!r}'.format(action.identifier())) from e

      if non_explicit:
        writer.default(non_explicit)

  def clean(self, recursive):
    build_directory = self.context.build_directory
    graph = self.context.graph

    ninja = check_ninja_version(build_directory)
    if not ninja:
      return 1

    if recursive:
      targets = [make_rule_name(graph, action) for action in graph.selected()]
    else:
      # Use -r and passing rules only cleans files that have been created by that rule.
      targets = ['rule_' + make_rule_name(graph, action) for action in graph.selected()]
      if targets:
        targets.insert(0, '-r')

    command = [ninja, '-f', os.path.join(build_directory, 'build.ninja'), '-t', 'clean']
    command += self.args
    command += targets
    return subprocess.call(command)

  def build(self, verbose):
    build_directory = self.context.build_directory
    graph = self.context.graph

    with ActionServer(graph) as server:
      os.environ['CRAFTR_ACTION_SERVER'] = '{}:{}'.format(*server.address())
      if verbose:
        os.environ['CRAFTR_VERBOSE'] = 'true'
      ninja = check_ninja_version(build_directory)
      if not ninja:
        return 1
      command = [ninja, '-f', os.path.join(build_directory, 'build.ninja')]
      command += self.args
      command += [make_rule_name(graph, action) for action in graph.selected()]
      return subprocess.call(command)


def make_rule_name(graph, action):
  return re.sub('[^\d\w_\.]+', '_', action.identifier())


def export_action(build_directory, writer, graph, action, non_explicit):
  phony_name = make_rule_name(graph, action)
  rule_name = 'rule_' + phony_name
  if not action.explicit:
    non_explicit.append(phony_name)

  command = [
    '$python',
    path.join(path.dir(__file__), 'buildslave.py'),
    # Place the hash in the command string, so Ninja always knows when
    # when the definition of the build action changed.
    '{}^{}'.format(action.identifier(), graph.hash(action)),
    '$index'
  ]
  command = ' '.join(quote(x, for_ninja=True) for x in command)

  implicit_deps = []
  for dep in action.deps:
    # Ensure that Ninja knows that there is at least an implicit dependency
    # betwene this action and its dependency. We do this by associating the
    # non-optional output files -- or otherwise the phony target.
    output_files = dep.all_files_tagged('out,!optional')
    if not output_files:
      output_files = [make_rule_name(graph, dep)]
    implicit_deps += output_files

  writer.rule(
    rule_name,
    command,
    pool = 'console' if action.syncio else None,  # TODO: Support for pools in modules
    depfile = action.depfile,
    deps = 'gcc' if action.depfile else ('msvc' if action.deps_prefix else None)
  )
  if action.deps_prefix:
    writer.variable('msvc_deps_prefix', action.deps_prefix, indent=1)

  for index, build in enumerate(action.builds):
    writer.build(
      outputs = list(build.files.tagged('out')) or [phony_name],
      rule = rule_name,
      inputs = list(build.files.tagged('in,!optional')),
      implicit = implicit_deps + list(build.files.tagged('in,optional')),
      variables = {'index': str(index)}
    )

  output_files = action.all_files_tagged('out')
  if output_files:
    writer.build([phony_name], 'phony', output_files)


new_backend = NinjaBackend
