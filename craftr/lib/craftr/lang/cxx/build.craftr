project "craftr/lang/cxx" v1.0.0

eval:
  options.setdefault('architecture', OS.arch)
  if OS.id == 'win32':
    if OS.type == 'nt':
      options.setdefault('toolchain', 'msvc')
    else:
      options.setdefault('toolchain', 'mingw')
  elif OS.id == 'darwin':
    options.setdefault('toolchain', 'clang')
  else:
    options.setdefault('toolchain', 'gcc')

options:
  str architecture
  str toolchain

eval:>>

import craftr from 'craftr'
import base from './impl/base'

# TODO: Support precompiled headers.
# TODO: Support compiler-wrappers like ccache.
# TODO: Support linker-wrappers (eg. for coverage).

class CxxTargetHandler(craftr.TargetHandler):

  def __init__(self, toolchain=None):
    toolchain, fragment = (toolchain or options.toolchain).partition('#')[::2]
    self.toolchain = toolchain
    self.compiler = require('./impl/' + toolchain).get_compiler(fragment)

    print('Selected compiler: {} ({}) {} for {}'.format(
      self.compiler.name, self.compiler.id, self.compiler.version, self.compiler.arch))

  def init(self, context):
    props = context.target_properties
    # Largely inspired by the Qbs cpp module.
    # https://doc.qt.io/qbs/cpp-module.html

    # General
    # =======================

    # Specifies the target type. Either `executable` or `library`.
    props.add('cxx.type', craftr.String, 'executable')

    # The name of the output file. This string may contain the string
    # `$(ext)` which will be replaced with the platform's proper extension.
    # It may also contain the string `$(lib)` which will be replaced by
    # `lib` on OSX and macOS but with an empty string on Windows.
    props.add('cxx.productName', craftr.String)

    # The C and/or C++ input files for the target. If this property is not
    # set, the target will not be considered a C/C++ build target.
    props.add('cxx.srcs', craftr.PathList, options={'inherit': True})

    # Allow the link-step to succeed even if symbols are unresolved.
    props.add('cxx.allowUnresolvedSymbols', craftr.Bool, False)

    # Combine C/C++ sources into a single translation unit. Note that
    # many projects can not be compiled in this fashion.
    props.add('cxx.combineCSources', craftr.Bool, False)
    props.add('cxx.combineCppSources', craftr.Bool, False)

    # Allow the linker to discard data that appears to be unused.
    # This value being undefined uses the linker's default.
    props.add('cxx.discardUnusedData', craftr.Bool)

    # Whether to store debug information in an external file or bundle
    # instead of within the binary. Defaults to True for MSVC, False
    # otherwise.
    props.add('cxx.separateDebugInformation', craftr.Bool)

    # Preprocessor definitions to set when compiling.
    props.add('cxx.defines', craftr.StringList, options={'inherit': True})
    props.add('cxx.definesForStaticBuild', craftr.StringList, options={'inherit': True})
    props.add('cxx.definesForSharedBuild', craftr.StringList, options={'inherit': True})

    # Include search paths.
    props.add('cxx.includes', craftr.PathList, options={'inherit': True})

    # Library search paths.
    props.add('cxx.libraryPaths', craftr.PathList, options={'inherit': True})

    # Paths for the dynamic linker. This is only used when running
    # the product of a build target via Craftr.
    props.add('cxx.runPaths', craftr.PathList, options={'inherit': True})

    # Dynamic libraries to link. You should use target dependencies
    # wherever possible rather than using this property.
    props.add('cxx.dynamicLibraries', craftr.PathList, options={'inherit': True})

    # Static libraries to link. You should use target dependencies
    # wherever possible rather than using this property.
    props.add('cxx.staticLibraries', craftr.PathList, options={'inherit': True})

    # Link with system libraries, where unspecified linkage.
    props.add('cxx.systemLibraries', craftr.StringList, options={'inherit': True})

    # List of files to automatically include at the beginning of
    # each translation unit.
    props.add('cxx.prefixHeaders', craftr.PathList, options={'inherit': True})

    # Optimization level. Valid values are `none`, `size` and `speed`.
    props.add('cxx.optimization', craftr.String)

    # Whether to treat warnings as errors.
    props.add('cxx.treatWarningsAsErrors', craftr.Bool)

    # Specifies the warning level. Valid values are `none` or `all`.
    props.add('cxx.warningLevel', craftr.String)

    # Flags that are added to all compilation steps, independent of
    # the language.
    props.add('cxx.compilerFlags', craftr.StringList, options={'inherit': True})

    # Specifies the way the library prefers to be linked. Either 'static' or 'dynamic'.
    props.add('cxx.preferredLinkage', craftr.String)

    # Flags that are added to C compilation.
    props.add('cxx.cFlags', craftr.StringList, options={'inherit': True})

    # Flags that are added to C++ compilation.
    props.add('cxx.cppFlags', craftr.StringList, options={'inherit': True})

    # The version of the C standard. If left undefined, the compiler's
    # default value is used. Valid values include `c89`, `c99` and `c11`.
    props.add('cxx.cStd', craftr.String)

    # The C standard library to link to.
    props.add('cxx.cStdlib', craftr.String)

    # The version of the C++ standard. If left undefined, the compiler's
    # default value is used. Valid values include `c++98`, `c++11`
    # and `c++14`.
    props.add('cxx.cppStd', craftr.String)

    # The C++ standard library to link to. Possible values are `libc++`
    # and `libstdc++`.
    props.add('cxx.cppStdlib', craftr.String)

    # Additional flags for the linker.
    props.add('cxx.linkerFlags', craftr.StringList, options={'inherit': True})

    # Name of the entry point of an executable or dynamic library.
    props.add('cxx.entryPoint', craftr.String)

    # Type of the runtime library. Accepted values are `dynamic` and
    # `static`. Defaults to `dynamic` for MSVC, otherwise undefined.
    # For GCC/Clang, `static` will imply `-static-libc` or flags alike.
    props.add('cxx.runtimeLibrary', craftr.String)

    # Whether to enable exception handling.
    props.add('cxx.enableExceptions', craftr.Bool, True)

    # Whether to enable runtime type information
    props.add('cxx.enableRtti', craftr.Bool, True)

    # Apple Settings
    # =======================

    # Additional search paths for OSX frameworks.
    props.add('cxx.frameworkPaths', craftr.PathList, options={'inherit': True})

    # OSX framework to link. If the framework is part of your project,
    # consider using a dependency instead.
    props.add('cxx.frameworks', craftr.StringList, options={'inherit': True})

    # OSX framework to link weakly. If the framework is part of your project,
    # consider using a dependency instead.
    props.add('cxx.weakFrameworks', craftr.StringList, options={'inherit': True})

    # A version number in the format [major] [minor] indicating the earliest
    # version that the product should run on.
    props.add('cxx.minimumMacosVersion', craftr.String)

    # Unix Settings
    # =======================

    # Generate position independent code. If this is undefined, PIC is
    # generated for libraries, but not applications.
    props.add('cxx.positionIndependentCode', craftr.Bool)

    # rpaths that are passed to the linker. Paths that also appear
    # in runPaths are ignored.
    props.add('cxx.rpaths', craftr.PathList, options={'inherit': True})

    # The version to be appended to the soname in ELF shared libraries.
    props.add('cxx.soVersion', craftr.String)

    # Visibility level for exported symbols. Possible values include
    # `default`, `hidden`, `hiddenInlines` and `minimal (which combines
    # `hidden` and `hiddenInlines`).
    props.add('cxx.visibility', craftr.String)

    # Windows Settings
    # =======================

    # Whether to automatically generate a manifest file and include it in
    # the binary. Disable this property if you define your own .rc file.
    props.add('cxx.generateManifestFile', craftr.Bool, True)

    # Specifies the character set used in the Win32 API. Defaults to
    # "unicode".
    props.add('cxx.windowsApiCharacterSet', craftr.String)

    # Advanced Settings
    # =======================

    # TODO

    # Map of defines by language name.
    #props.add('cxx.definesByLanguage', 'Map[String, Map[String]]')

    # Map of defines by compiler ID.
    #props.add('cxx.definesByCompiler', 'Map[String, Map[String]]')

    # Map of defines by platform ID.
    #props.add('cxx.definesByPlatform', 'Map[String, Map[String]]')

    # Save temporary build prodcuts. Note that some toolchains (such as MSVC)
    # can not compile AND actually build at the same time.
    props.add('cxx.saveTemps', craftr.Bool, False)

    # Dependency Properties
    # =======================

    props = context.dependency_properties

    # If False, the dependency will not be linked, even if it is a valid
    # input for a linker rule. This property affects library dependencies only.
    props.add('cxx.link', craftr.Bool, True)


    self.compiler.init(context)

  def translate_target(self, target):
    data = target.get_props('cxx.', as_object=True)

    if not data.preferredLinkage:
      data.preferredLinkage = 'static'
    if data.preferredLinkage not in ('static', 'shared'):
      error('invalid cxx.preferredLinkage: {!r}'.format(data.preferredLinkage))

    if not data.productName:
      data.productName = '$(lib)' + target.name + '-' + target.module.version + '$(ext)'
    if data.type == 'executable':
      repl = {'$(lib)': '', '$(ext)': self.compiler.executable_suffix}
      tags = ['exe']
      suggestedName = '{}$(ext)'
    elif base.is_sharedlib(data):
      repl = {'$(lib)': self.compiler.library_prefix, '$(ext)': self.compiler.library_shared_suffix}
      tags = ['lib', 'sharedlib']
    elif base.is_staticlib(data):
      repl = {'$(lib)': self.compiler.library_prefix, '$(ext)': self.compiler.library_static_suffix}
      tags = ['lib', 'staticlib']
    else:
      raise RuntimeError('what is this?', data)
    for a, b in repl.items():
      data.productName = data.productName.replace(a, b)

    data.productTags = tags
    data.productFilename = path.join(craftr.get_output_directory(target), data.productName)

    self.compiler.translate_target(target, data)

    c_srcs = []
    cpp_srcs = []
    for filename in data.srcs:
      if filename.endswith('.c'): c_srcs.append(filename)
      if filename.endswith('.cpp') or filename.endswith('.cc'):
        cpp_srcs.append(filename)

    compile_actions = []
    obj_files = []
    for (srcs, lang) in ((c_srcs, 'c'), (cpp_srcs, 'cpp')):
      if not srcs: continue
      name = 'cxx.compile' + lang.capitalize()
      action = self.compiler.create_compile_action(target, data, name, lang, srcs)
      compile_actions.append(action)

    if compile_actions:
      lang = 'cpp' if cpp_srcs else 'c'
      link_action = self.compiler.create_link_action(target, data, 'cxx.link', lang, compile_actions)
    else:
      link_action = None

    if link_action and data.type == 'executable':
      command = [data.productFilename]
      action = target.add_action('cxx.run', commands=[command],
        explicit=True, syncio=True, output=False)
      action.add_buildset()


handler = CxxTargetHandler()
compiler = handler.compiler

context.register_handler(handler)
