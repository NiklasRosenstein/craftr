
import craftr
from craftr import path


def partition_sources(sources, src_roots, parent):
  """
  Partitions a set of files in *sources* to the appropriate parent directory
  in *src_roots*. If a file is found that is not located in one of the
  *src_roots*, a #ValueError is raised.

  A relative path in *sources* and *src_roots* will be automatically converted
  to an absolute path using the *parent*, which defaults to the currently
  executed module's directory.
  """

  abs_roots = [path.canonical(x, parent) for x in src_roots]
  result = {}
  for source in [path.canonical(x, parent) for x in sources]:
    for root, rel_root in zip(abs_roots, src_roots):
      rel_source = path.rel(source, root)
      if path.isrel(rel_source):
        break
    else:
      raise ValueError('could not find relative path for {!r} given the '
        'specified root dirs:\n  '.format(source) + '\n  '.join(base_dirs))
    result.setdefault(rel_root, []).append(rel_source)
  return result


class JavaTargetHandler(craftr.TargetHandler):

  def __init__(self):
    # A list of artifacts to fetch.
    self.artifacts = []

  def get_common_property_scope(self):
    return 'java'

  def setup_target(self, target):
    target.define_property('java.srcs', 'StringList', inheritable=False)
    target.define_property('java.srcRoots', 'StringList', inheritable=False)
    target.define_property('java.compilerFlags', 'StringList')
    target.define_property('java.jarName', 'String', inheritable=False)
    target.define_property('java.mainClass', 'String', inheritable=False)
    target.define_property('java.distType', 'String')  # The distribution type for applications, can be `none`, `onejar` or `merge`.
    target.define_property('java.binaryJars', 'StringList')
    target.define_property('java.artifacts', 'StringList')
    target.define_property('java.runPrefix', 'StringList', inheritable=False)
    target.define_property('java.run', 'StringList', inheritable=False)

  def setup_dependency(self, target):
    # Whether to embedd the library when combining JARs. Defaults
    # to True for applicaton JARs, False to library JARs.
    target.define_property('java.embed', 'Bool')

  def finalize_target(self, target, data):
    if not data.srcs:
      return
    self.artifacts += data.artifacts
    build_dir = path.join(context.build_directory, target.module().name())

    if not data.srcRoots:
      data.srcRoots = ['src', 'java', 'javatest']
    if not data.jarName:
      data.jarName = (target.name() + '-' + target.module().version())

    # Construct the path to the output JAR file.
    data.jarFilename = path.join(build_dir, data.jarName + '.jar')

    # Create a list of all the Java Class files generated by the compiler.
    data.classDir = path.join(build_dir, 'cls')
    data.classFiles = []
    for root, sources in partition_sources(data.srcs, data.srcRoots,
                                           target.directory()).items():
      for src in sources:
        clsfile = path.join(data.classDir, path.setsuffix(src, '.class'))
        data.classFiles.append(clsfile)

    # TODO: Download artifacts.
    # TODO: Append to binaryJars the products of Java dependencies.
    # TODO: Append to binaryJars the JARs of downloaded artifacts.
    # TODO: If we produce an executable, don't tag the file as 'javaLibrary'.
    target.outputs().add(data.jarFilename, ['javaLibrary'])

  def translate_target(self, target, data):
    if not data.classFiles:
      return

    # Generate the action to compile the Java source files.
    command = [javac, '-d', data.classDir]
    if data.binaryJars:
      command += ['-classpath', data.binaryJars]
    command += ['$in']
    command += data.compilerFlags
    action = target.add_action('java.javac', commands=[command])
    build = action.add_buildset()
    build.files.add(data.srcs, ['in'])
    build.files.add(data.classFiles, ['out'])

    # Generate the action to produce the JAR file.
    flags = 'cvf'
    if data.mainClass:
      flags += 'e'
    command = [javacJar, flags, '$out']
    if data.mainClass:
      command += [data.mainClass]
    command += ['-C', data.classDir, '.']
    action = target.add_action('java.jar', commands=[command])
    build = action.add_buildset()
    build.files.add(data.classFiles, ['in'])
    build.files.add(data.jarFilename, ['out'])

    # An action to execute the JAR file.
    command = (data.runPrefix or ['java']) + ['-jar', data.jarFilename]
    action = target.add_action('java.run', commands=[command], explicit=True, syncio=True)
    action.add_buildset()


module.register_target_handler(JavaTargetHandler())
