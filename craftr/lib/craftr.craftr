# This file is loaded by the craftr.main.Context where the `context`
# variable is available.

project "craftr" v1.0.0
eval:>>

__builtins__ = ['BUILD', 'OS', 'path', 'error', 'fmt', 'glob']
__all__ = __builtins__ + ['option_default', 'get_output_directory', 'relocate_files', 'sh']

from nr import path

import collections
import os
import platform
import sys
import types

import {BuildBackend} from '@craftr/craftr-build/build'
import {Target, Dependency, Module, TargetHandler} from '@craftr/craftr-build/core'
import {ExplicitRunError} from '@craftr/craftr-build/dsl'
import {Bool, Integer, String, List, Dict, StringList} from '@craftr/craftr-build/proplib'
import sh from '@craftr/craftr-build/utils/sh'

OsInfo = collections.namedtuple('OsInfo', 'name id type arch')


class BuildInfo(collections.namedtuple('_BuildInfo', 'variant')):

  @property
  def debug(self):
    return self.variant == 'debug'

  @property
  def release(self):
    return self.variant == 'release'


def get_call_context(stackdepth=1, dependency=True, target=True, module=True):
  """
  Returns the #Module, #Target or #Dependency from the
  parent stackframe. Raises a #RuntimeError if it can not be determined.
  """

  f= sys._getframe(stackdepth+1)
  scope = sys._getframe(stackdepth+1).f_globals
  if '__dict__' in scope:
    # For code evaluated with nr.ast.dynamic_eval().
    scope = scope['__dict__']
  if dependency and isinstance(scope.get('self'), Dependency):
    return scope['dependency']
  elif target and isinstance(scope.get('target'), Target):
    return scope['target']
  elif module and isinstance(scope.get('module'), Module):
    return scope['module']
  raise RuntimeError('Call context could not be determined')


def error(*message):
  raise ExplicitRunError(' '.join(map(str, message)))


def fmt(s, frame=None):
  """
  Formats the string *s* with the variables from the parent frame or the
  specified frame-object *frame*.
  """

  import inspect
  import gc
  import types
  class Resolver:
    def __init__(self, frame):
      self.frame = frame
      self._func = NotImplemented
    @property
    def func(self):
      if self._func is NotImplemented:
        self._func = next(filter(lambda x: isinstance(x, types.FunctionType),
            gc.get_referrers(self.frame.f_code)), None)
      return self._func
    def __getitem__(self, key):
      # Try locals
      try: return self.frame.f_locals[key]
      except KeyError: pass
      # Try non-locals
      try:
        index = self.frame.f_code.co_freevars.index(key)
      except ValueError:
        pass
      else:
        if self.func:
          x = self.func.__closure__[index]
          return x
      # Try globals
      try: return self.frame.f_globals[key]
      except KeyError: pass

  frame = frame or inspect.currentframe().f_back
  vars = Resolver(frame)
  return s.format_map(vars)


def glob(patterns, parent=None, excludes=None):
  if not parent:
    obj = get_call_context(dependency=False)
    parent = obj.directory
  return path.glob(patterns, parent, excludes)


def get_output_directory(target, *subdir):
  return path.join(context.build_directory, target.module.name, target.name, *subdir)


def relocate_files(parent, files, outdir, suffix, replace_suffix=True):
  """
  Converts the list of filenames *files* so that they are placed under
  *outdir* instead of *parent* and have the specified *suffix*. If
  *replace_suffix* is #True (default), then the file's suffix will be
  replaced, otherwise appended.
  """

  outdir = path.canonical(outdir)
  parent = path.canonical(parent)

  result = []
  for filename in files:
    filename = path.join(outdir, path.rel(path.canonical(filename), parent))
    filename = path.addsuffix(filename, suffix, replace=replace_suffix)
    result.append(filename)

  return result


if sys.platform.startswith('win32'):
  OS = OsInfo('windows', 'win32', os.name, 'x86_64' if os.environ.get('ProgramFiles(x86)') else 'x86')
elif sys.platform.startswith('darwin'):
  OS = OsInfo('macos', 'darwin', 'posix', 'x86_64' if sys.maxsize > 2**32 else 'x86')
elif sys.platform.startswith('linux'):
  OS = OsInfo('linux', 'linux', 'posix', 'x86_64' if sys.maxsize > 2**32 else 'x86')
else:
  raise EnvironmentError('(yet) unsupported platform: {}'.format(sys.platform))


BUILD = BuildInfo(context.build_variant)
