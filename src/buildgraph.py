
import collections
import hashlib
import json
import os
import time


class BuildAction:
  """
  Represents a concrete sequence of system commands.
  """

  def __init__(self, scope, name, commands, input_files, output_files, deps,
               cwd, environ, foreach, explicit, console):
    assert isinstance(scope, str), type(scope)
    self.scope = scope
    self.name = name
    self.commands = commands
    self.input_files = input_files
    self.output_files = output_files
    self.deps = deps
    self.cwd = cwd
    self.environ = environ
    self.foreach = foreach
    self.explicit = explicit
    self.console = console

  def __repr__(self):
    return '<BuildAction {!r}>'.format(self.identifier())

  def identifier(self):
    return '{}#{}'.format(self.scope, self.name)

  def as_json(self):
    result = vars(self).copy()
    result['deps'] = [x.identifier() for x in self.deps]
    return result

  @classmethod
  def from_json(cls, data, nodes):
    data['deps'] = [nodes[x] for x in data['deps']]
    return cls(**data)

  @staticmethod
  def normalize_file_list(lst, foreach):
    """
    Normalizes a list of filenames. This will result in a `List[List[str]]`.
    If *foreach* is #False, there will be exactly one item in the returned
    list, that matches the files in *lst*.
    """

    result = [] if foreach else [[]]
    for item in lst:
      if foreach:
        if isinstance(item, str):
          item = [item]
        if not isinstance(item, (list, tuple)):
          raise ValueError('expected List[^List[str]]-like, got {!r}'.format(item))
        if not all(isinstance(x, str) for x in item):
          raise ValueError('expected List[List[^str]], got {!r}'.format(item))
        result.append(item)
      else:
        if not isinstance(item, str):
          raise ValueError('expected List[^str], got {}'.format(type(item).__name__))
        result[-1].append(item)
    return result



class BuildGraph:
  """
  Represents the actions generated by targets in a more easily accessible
  datastructure, which also supports saving to and loading from disk.
  """

  def __init__(self):
    self._actions = {}
    self._scopes = {}
    self._selected = []
    self._mtime = time.time()

  def __getitem__(self, key):
    """
    Retrieve an action by its full identifier.
    """

    return self._actions[key]

  def from_actions(self, actions):
    """
    Fill the #BuildGraph from the iterable *actions* which contains only
    #BuildAction objects.
    """

    for action in actions:
      self._actions[action.identifier()] = action
      self._scopes.setdefault(action.scope, []).append(action)
    return self

  def from_json(self, data):
    """
    Fills the #BuildGraph from the JSON representation *data*.
    """

    for key, value in data['actions'].items():
      value = value.copy()
      value['deps'] = []
      action = BuildAction(**value)
      self._actions[key] = action
    for key, value in data['actions'].items():
      self._actions[key].deps = [self._actions[x] for x in value['deps']]
    self._scopes.update({k: [self._actions[x] for x in v] for k, v in data['scopes'].items()})

  def as_json(self):
    """
    Converts the #BuildGraph to a JSON representation which can be saved to
    disk using #json.dump() and loaded back using #json.load() and the
    #from_json() method.
    """

    return {
      'actions': {x.identifier(): x.as_json() for x in self._actions.values()},
      'scopes': {k: [action.identifier() for action in scope]
                    for k, scope in self._scopes.items()}
    }

  def read(self, filename):
    """
    Loads the #BuildGraph from a JSON representation previously saved with
    #write(). Note that this method will update the #mtime of the graph.
    """

    with open(filename, 'r') as fp:
      self.from_json(json.load(fp))
    self._mtime = os.path.getmtime(filename)
    return self

  def write(self, filename):
    """
    Writes the #BuildGraph to the specified *filename* in JSON format.
    """

    os.makedirs(os.path.dirname(filename), exist_ok=True)
    with open(filename, 'w') as fp:
      json.dump(self.as_json(), fp)

  def actions(self):
    """
    Iterable for all actions in the #BuildGraph.
    """

    return self._actions.values()

  def hash(self, action):
    """
    Generate a hash for an action in the #BuildGraph.
    """

    data = json.dumps(action.as_json(), sort_keys=True)
    return hashlib.sha1(data.encode('utf8')).hexdigest()[:12]

  def dotviz(self, fp):
    """
    Outputs a Dotviz markup for the #BuildGraph.
    """

    fp.write('digraph "craftr" {\n')
    for node in self.actions():
      fp.write('\t{} [label="{}" shape="round" style="rounded"];\n'.format(id(node), node.identifier()))
      for dep in node.deps:
        fp.write('\t\t{} -> {};\n'.format(id(dep), id(node)))
    fp.write('}\n')

  def select(self, *actions):
    """
    Marks one or more actions in the graph as selected. The selected actions
    can be retrieved using the #selected() method. Parameters passed to this
    function may either be #BuildAction instances, or strings that either
    identify a #BuildAction or a scope.
    """

    for action in actions:
      if isinstance(action, BuildAction):
        self._selected.append(action.identifier())
      elif action in self._actions:
        self._selected.append(action)
      elif action in self._scopes:
        self._selected.extend(x.identifier() for x in self._scopes[action])
      else:
        raise ValueError(action)

  def deselect_all(self):
    """
    Deselects all actions in the graph.
    """

    self._selected = []

  def selected(self):
    """
    Returns a generator that yields all selected actions.
    """

    return (self[k] for k in self._selected)

  def mtime(self):
    """
    Returns the last modification time of the #BuildGraph. If read from a
    file, the value will equal the modification time of the file.
    """

    return self._mtime
